# C++ Primer Chapter 4:4.5-4.9
## 递增和递减运算符
* 递增运算符（++）和递减运算符（--）为对象的加1和减1操作提供了一种简洁的书写形式。这两个运算符还可应用于迭代器，因为迭代器本身不支持算术运算，所以此时递增和递减运算除了书写简介外还是必须得。
* 递增和递减运算符有两种形式：前置版本和后置版本。到目前为止，本书使用的都是前置版本，这种形式的运算符首先将运算对象加一，然后将改编后的对象作为求值结果。后置版本也会将运算对象加一，但是求值结果是运算对象改变之前那个值的副本。

        除非必须，否则不建议使用递增递减的后置版本
        前置版本的递增运算符避免了不必要的工作，它把值加一后直接返回改变了的运算对象。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。
        对于整数和指针类型来说，编译器可能对这种额外的工作进行一定优化；但是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。

### 在一条语句中混用解引用和递增运算符
* 如果我们想在一条复合表达式中即将变量加一或减一又能使用它原来的值，这是就可以使用递增或递减的后置版本。
* 举个例子，可以使用后置的递增运算符来控制循环输出一个vector对象内容直至遇到（但不包括）第一个负值为止：

        auto pbeg=v.begin();
        //输出元素直至遇到第一个负值为止
        while(pbeg!=v.end()&&*beg>=0)
        {
            cout<<*pbeg++<<endl;//输出当前值，并将pbeg向前移动一个元素
        }

* 后置递增运算符的优先级高于解引用运算符，因此*pbeg++等价于 *（pbeg++）。
* 这种做法完全基于一个事实，即后置递增运算符返回出事的未加一的值。如果返回的是加一之后的值，解引用该值将引发错误的结果，不但无法输出第一个元素，而且更糟糕的是如果数列中没有负值，程序将可能试图解引用一个根本不存在的元素。

### 运算对象可按任意顺序求值
* 如果一条做表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，运算对象的求值顺序就很关键了。因为递增运算符合递减运算符会改变运算对象的值，所以要提防在复合表达式中错用这两个运算符。
* 为了说明这一问题，改写程序使用foe循环将输入的第一个单词改成大写形式：

        for(auto it=s.begin();it!=s.end()&&!isspace(*it);++it)
        {
            *it=toupper(*it);//将当前字符改成大写形式
        }
* 在上述程序中，我们把解引用it和递增it两项任务分开完成。如果用一个看似等价的while循环进行代替：

        while(beg!=s.end()&&!isspace(*beg))
        {
            *beg=toupper(*beg);//错误：该赋值语句未定义
        }
* 将产生未定义的行为。问题在于：赋值运算符对象都用到了beg，并且右侧的运算对象还改变了beg的值，所以该赋值语句是未定义的。编译器可能按照下面任意一种思路处理该表达式：

        *beg=toupper(*beg);//如果先求左边的值
        *(beg+1)=toupper(*beg);//如果先求右侧的值
* 也可能采取别动方式处理它


## 成员访问运算符
* 点运算符和箭头运算符都可用于访问成员，其中，点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式ptr->mem等价于(*ptr).mem:

        string s1="a string",*p=&s1;
        auto n=s1.size();//运行string对象s1的size成员
        n=(*p).size();//运行p所指对象的size成员
        n=p->size();//等价于(*p).size()

* 箭头运算符作用与一个指针类型的运算对象，结果是一个左值。点运算符分成两种情况，如果成员所属的对象是左值，那么结果是左值，反之，则为右値。


## 条件运算符
* 允许在条件运算符的内部嵌套另外一个条件运算符。也就是卓，条件表达式可以作为另外一个条件运算符的cond或expr。举个例子，使用一对嵌套的条件运算符可以将成绩分成三挡：优秀、合格、不及格。

        finalgrade=(grade>90)?"high pass":(grade<60)?"fail":"pass";
* 条件运算符满足又结合律，意味着云撒UN对象啊ing（一般）按照从右向左的顺序组合。因此在上面的代码中，靠右边的条件运算（比较成绩是否小于60）构成了靠左边的条件运算的：分支。
* 随着条件运算符嵌套层数的增加，代码的可读性急剧下降。一次你，条件运算符的嵌套最好别超过两到三层。

### 在输出表达式中使用条件运算符
* 条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式时，通常在它的两大UN加上括号

## 位运算符
* 位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合，位运算符提供检查和设置二进制位的功能。一种名为bitset的标准库类型也可以表示任意大小的二进制位集合，所以位运算符同样能作用于bitset类型。
![位运算符](位运算符.PNG)
* 如果运算对象是带符号的且它的值是负的，那么位运算符如何处理运算对象的“符号位”依赖于机器。而且，此时的左移操作坑能会改变符号位的值，因此是一种为定义的行为。
* 关于符号为如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型。

### 移位运算符
* 之前在处理输入和输出操作时，我们已经是用过标准IO库定义的<<运算符和>>运算符的重载版本。这两种运算符的内置含义是对其运算执行给予二进制位的移动炒作，首先令其左侧运算对象内容的按照要求移动指定位数，然后将经过移动的左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生未定义的行为。二进制或者向左移(<<)或者向右移(>>)，移出边界之外的位就被舍弃掉了。
* `左移运算符(<<)`在右侧插入值为0的二进制位，右移运算符(>>)的行为则依稀预期左侧运算对象的类型；如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或者值为0的二进制位，如何选择要视具体环境而定。

### 位求反运算符
* `位求反运算符（~）`将运算对象逐位囚犯后生成一个新值，将1置为0、将0置为1
* char类型的运算对象首先提升成int类型，提升是运算对象原来的为保持不变，往高位（high order position）添加0即可。因此在本例中，首先将bits提升成int类型，增加24个高位0，随后将提升后的值逐位求反。

### 位与、位或、位异或运算符
* 对于位与运算符来说，如果两个运算对象的对应位置都是1则运算结果中该位为1，否则为0，。对于位或运算符来说，如果两个运算对象的对应位置至少有一个为1则运算结果中该位为1，否则为0.对于位异或运算符来说，如果两个运算对象的对应位置有且只有一个为1则运算结果中该位为1，否则为0.
* 有一种常见错误是吧位运算符和逻辑运算符搞混了。

### 使用位运算符
* 我们举一个使用位运算符的例子，假设班级中有30个学生。老师每周会对学生进行一次小测验，测验的结果只有通过和不通过两种。为了更好地追踪测验的结果，我们用一个二进制位代表某个学生在一次测验中是否通过，显然全班的测验结果可以用一个无符号整数来表示：

        unsigned long quizi=0;//我们把这个值当成是位的集合来使用
* 定义quiz1的类型是unsigned long，这样，quiz1在任何机器上豆浆至少拥有32位；给quiz1赋一个明确的初始值，使得它的每一位在开始时都有统一且固定的值。
* 教师必须有权设置并检查每一个二进制位。例如，我们需要对序号为27的学生对应的位进行设置，仪表室他ton过了测验。为了达到这一目的，首先创建一个值，该值只有第27位是1其他位都是0，然后将这个值与quiz1进行位或运算，这样就能强行将quiz1的第27位设置为1，其他位都保持不变。
* 为了实现本例的目的，我们将quiz1的低阶位赋值为0、下一位赋值为1，以此类推，最后统计quiz1各个位的情况。
* 使用左移运算符和一个unsigned long类型的整数字面值1就能得到一个表示学生27通过了测验的数值。

        1UL<<27   //生成一个值，该值只有第27位为1
* 1UL低阶位上有一个1，除此之外，还有31个值为0的位，之所以使用unsigned long类型，是因为int 类型只能确保占用16位，而我们至少需要27位.上面这条表达式通过在值为一的那个二进制位后面添加0，使得他向左移动了27位。

### 移位运算符（又叫IO运算符）满足左结合律
* 尽管很多程序员从未直接使用过位运算符，但是几乎所有人都用过他们的重载版本来进行IO操作。重载运算符的优先级和结合律都与它的内置版本一样，因为即使程序员用不到移位运算符的内置含义，也仍然有必要了解其优先级和结合路。
* 移位运算符的优先级不高不低，街与中建：比算数运算符的优先级低，单笔关系运算符、赋值运算符和条件运算符的优先级高。因为再一次使用多个运算符时，有必要在适当的地方加上括号时期满足我们的要求。

## sizeof运算符
* sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。运算符的运算对象有两种形式：

                sizeof(type)
                sizeof expr
* 在第二种形式中，sizeof返回的是表达式结果类型的大小，与众不同的一点是，sizeof并不实际计算其运算对象的值：

                Sales_date date,*p;
                sizeof(Sales_date);//存储Sales_date类型对象所占的空间大小
                sizeof date;//date的类型的大小，即sizeof(Sales_date)
                sizeof p;//指针所占空间的大小
                sizeof *p;//p所值类型的空间大小
                sizeof date.revenue；//Sales_date的revenue成员对应类型的大小
                sizeof Sales_date::revenue;//同上
* c++11新标准允许我们使用作用与运算符来获取类成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但是sizeof运算符无需我们提供一个具体的对象，因为要想知道类成员的大小无需真的获得该成员。
* sizeof运算符的结果部分地依赖于起作用的类型：
  * 对于char或者类型为char的表达式执行sizeof运算，结果得1
  * 对引用类型执行sizeof运算得到被引用对象所占空间的大小。
  * 对指针执行sizeof运算得到的指针本身所占空间的大小。
  * 对接引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效。
  * 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组准换成指针来处理。
  * 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。


## 逗号运算符
* `逗号运算符(comma operator)`含有两个运算对象，按照从左向右的顺序依次求职。和逻辑与、逻辑或以及条件运算符一样，逗号运算符也规定了云撒UN对喜爱那个求职的顺序。
* 对于逗号运算符来说，首先对左侧的表达式求值，然后将球直接过丢掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的球直接过也是左值。
* 逗号运算符经常被用在for循环当中：

                vector<int>::size_type cnt=ivec.size();
                //将把从size到1的值赋给ivec的元素
                for(vector<int>::size_type() ix=0;ix!=ivec.size();++ix,--cnt)
                {
                        ivec[ix]=cnt;
                }
* 这个循环在for语句的表达式中递增ix、递减cnt，每次循环迭代ix和cnt相应改变，只要ix满足条件，我们酒吧当前元素设成cnt的当前值。