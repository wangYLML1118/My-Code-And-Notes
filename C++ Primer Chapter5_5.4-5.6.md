# C++ Primer Chapter 5：5.4-5.6try语句块和异常处理
## 迭代语句
* 迭代语句通常称为循环，它重复执行操作直到满足某个条件才停下来。while和for语句执行循环体之前检查条件，do while语句先执行循环体，然后再检查条件。

## while语句
* 只要条件为真，`while语句`就重复执行循环体，它的语法形式是

        while(consition)
        {
            statment;
        }
* while的条件部分可以使一个表达式或者一个带初始化的变量声明。通常来说，应该有条件本身或者循环体设法改变表达式的值，否则循环可能无法终止。
* 定义在while循环条件部分或者while循环体内的变量每次迭代窦经理从创建到销毁的过程。
### 使用while循环
* 当不确定还要迭代多少次时，使用while循环比较合适，比如读取输入的内容就是如此。还有一种情况也应该使用while循环，这就是我们想在循环结束后访问循环控制变量。

## 传统的for语句
* for语句的语法形式是

        for(init-statment;condition;expression)
        {
            statment;
        }
* 关键字for及括号里的部分称为for语句头。
* init-statment必须是一下三种形式中的一种：声明语句、表达式语句或者空语句，因为condition作为循环控制的条件，只要condition为真，就执行一次statment。如果condition第一次求值结果就是false，则statment一次也不会执行。

### 传统for循环的执行流程
* 求值顺序如下所示;

        1、循环开始时，首先执行一次init-statment
        2、接下来判断condition
        3、如果条件为真，执行循环体。
        4、最后执行expression。
* 牢记for语句头中定义的对象只在for循环体内可见，

### for语句头中的多重定义
* 和其他声明一样，init-statment也可以定义多个对象，但是init-statment只能有一条声明语句，因此，所有变量的基础类型必须相同。举个例子，我们用下面的循环把vector的元素拷贝一份添加到原来的元素后面：

        //记录下v的大小，当达到原来的最后一个元素后结束循环
        for(decltype(v.size()) i=0;sz=v.size();i!=sz;+=i)
        {
            v.push_back(c[i]);
        }

### 省略for语句头的某些部分
* for语句能省略掉init-statment、condition和expression中的任何一个（或者全部）。
* 如果无需初始化，则我们可以使用一条空语句作为init-statment。例如，对于在vector对象中寻找第一个负数的程序，完全能用for循环改写。

                auto beg=v.begin();
                for(;beg!=v.end()&&*beg>=0;++beg)
                {
                        ;//什么也不做
                }


## 范围for语句
* c++11新标准引入了一种更简单的for语句，这种语句可以遍历容器或其他序列的所有元素，范围for语句（range for statment）的语法形式是：

                for(declaration:expression)
                {
                        statment;
                }
* expression表示的必须是一个序列，比如用花括号括起来的初始值列表、数组或者vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员。
* declaration定义一个变量，序列中的每个元素都能转换成该变量的类型。确保类型相容最简单的办法是使用auto累心该说明符，这个关键字可以领编译器帮助我们制定合适的类型。如果需要对序列中的元素执行写操作，循环变量必须声明成引用类型。
* 每次迭代都会重新定义循环控制变量，并将其初始化成序列中的下一个值。
* 之前我们接触过几个这样的循环，接下来的例子将把vector对象中的每个元素都翻倍，它涵盖了范围for语句几乎所有的语法特征：

                vector<int> V={0,1,2,3,4,5,6,7,8,9};
                //范围变量必须是引用类型，这样才能对元素执行写操作
                for(auto &r:V)//对于V中的每一个元素
                {
                        r*=2;
                }
* for语句头声明了循环控制变量r，并把它和V关联在一起，我们使用关键字auto令编译器为r制定正确的类型。由于准备修改v的元素的值，因此将r声明成引用类型，此时，在循环体内给r赋值，既改变了r所绑定的元素的值。

## do while语句
* `do while语句`和while语句非常相似，唯一的区别是，do while语句先检查循环体后检查条件。不管条件的值如何，我们都至少执行一次循环。do while语句的语法形式如下所示：

                do
                        statment
                while(condition)
* do while语句应该在括号包围起来的条件后面用一个分号表示语句结束。
* 在do语句中，求condition的值之前受限制性一次statment，condition不能为空。


## 跳转语句
* 跳转语句中断当前的执行过程。c++语言提供了4中跳转语句：break、continue、goto和return。本章介绍前三种跳转语句，return语句将在之后介绍。

## break语句
* `break语句`负责终止离他最近的while、do while、for或switch语句，并从这些语句之后的第一条语句开始执行。

## continue语句
* `continue语句`终止最近的循环中的当前迭代并立即开始下一次迭代，continue语句只能出现在for、while和do while循环的内部，或者嵌套在此类循环里的语句或块内部，和break语句类似的事，出现在嵌套循环中的聪体虐语句只作用于离他们最近的循环。和break语句不同的是，只有当switch语句嵌套在迭代语句内不是，才能在switch里使用continue。
* continue语句中断当前迭代，但是仍然继续执行循环。对于while或者do while语句来说，继续判断条件的值；对于传统的for循环来说，继续执行for语句头的expression；而对于范围for语句来说，则是用序列的下一个元素初始化循环控制变量。

## goto语句
* goto语句的作用是从goto语句无条件跳转到同一函数内的另一条语句。
  * 不要在程序中使用goto语句，因为它使得程序急难理解又难修改
* goto语句的语法形式是：

                goto label;
* 其中label适用于标识一条语句的标识符。`带标签语句（labeled statment）`是一种特殊的语句，在它之前有一个标识符以及冒号。

## try语句块和异常处理
* 异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异常包括市区数据库连接以及遇到意外输入等。处理翻唱行为可能是设计所有系统最难的一部分。
* 当程序的某部分检测到一个他无法处理的问题时，曦要用到异常处理。此时，检测出问题的部分应该发出某种信号已表明程序遇到了故障，无法继续下去了，而且信号的发出方无需知道故障将在何处得到解决。一旦发出异常信号，检测出问题的部分也就完成了任务。
* 如果程序中含有坑能引发异常的代码，呢么通常也会有专门的代码处理问题，例如，如果程序的问题是输入无效，则异常处理部分可能会要求用户重新输入正确的数据；如果丢失了数据库连接，会发出警报信息。
* 异常处理机制为程序中异常检测和异常处理这两部分的写作提供支持。在c++语言中，异常处理包括：

                1、`throw表达式`，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw`引发`了异常
                2、`try语句块`，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个catch子句结束。try语句块中代码跑出的异常通常会被某个catch语句处理。因为catch子句“处理”异常，所以他们也被称作`异常处理代码`。
                3、一套`异常类`,用于在throw表达式和相关的catch子句之间的传递一场的具体信息

## throw表达式
* 程序的异常检测部分使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的额类型就是跑出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。
* 举个简单的例子，回忆之前把两个Sales_item对象相加的程序。这个程序检查它读入的记录是否是关于同一种书记的，如果不是，输出一条信息然后退出。

                Sales_item item1,item2;
                cin>>item1>>item2;
                //首先检查item1和item2是否标识同一种书籍
                if(item1.isbn()==item2.isbn())
                {
                        cout<<item1+item2<<endl;
                        return 0;//表示成功
                }
                else
                {
                        cerr<<"Date must refer to same ISBN">>endl;
                        return -1;//表示失败
                }
* 在真实的程序中，应该把对象相加的代码和用户交互的代码分离开来。此例中，我们改写程序使得检查完成后不在输出一条信息，而是抛出一个异常：

                //首先检查两条数据是否是关于同一种书籍的
                if(item1.isbn()!=item2.isbn())
                {
                        throw runtime_error("Date must refer to same ISBN");
                }
                //如果程序执行到了这里，表示两个isbn是相同的
                cout<<item1+item2<<endl;
* 在这段代码中，如果isbn不相同就抛出一个异常，该异常是类型runtime_error的对象。抛出异常将中止当前的函数，并把控制权转移给能处理该异常的代码。
* 类型runtime_error是标准库异常类型的一种，定义在stdexpect头文件中。关于标准库异常类型更多的只是将在以后介绍，我们必须初始化runtime_error的对象，方式是给他提供一个string对象，或者一个C风格的字符串，这个字符串中有一些关于异常的辅助信息。

## try语句块
* try的通用语法形式是：

                try
                {
                        program-statments
                }
                catch(expection-declaration)
                {
                        handler-statment
                }
                catch(expection-declaration)
                {
                        handler-statment
                }//...
* try语句块一开始是关键字try，随后紧跟着一个块，这个块就像大多数时候那样是花括号括起来的语句序列。
* 跟在try块之后的是一个或多个catch子句。catch子句包括三部分：关键字catch、括号内一个（可能未命名的）对象的声明（称作异常声明）以及一个块。当选中了某个catch子句处理异常之后，执行与之对应的块，catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。
* try语句中的program-statment组成程序的正常逻辑，想起他任何块一样，program-statments可以有包括在内的任意c++语句。一如句王，try语句块内声明的变量在块外部无法访问，特别是在catch子句内也无法访问。

### 编写处理代码
* 在之前的李自力，我们使用了一个throw表达式以避免吧两个地表不同书记的Sales_item相加。我们假设执行Sales_item对象加法的代码是与用户交互的代码分离开来的。其中与用户交互的代码负责处理发生的异常，它的形式可能如下图所示：

                while(cin>>item1>>item2)
                {
                        try
                        {
                                //执行添加两个Sales_item对象的代码，如果添加失败，代码跑出一个runtime_error异常
                        }
                        catch(runtime_error err)
                        {
                                //提醒用户两个ISBN必须一致，询问是否重新输入
                                cout<<err.what()
                                    <<"\ntry Again? Enter y or n"<<endl;
                                char c;
                                cin<<c;
                                if(!cin||c=='n')
                                {
                                        break;//跳出while循环
                                }
                        }
                }
* 程序本来要执行的任务出现在try语句块中，这是因为这段代码可能会抛出一个runtime_error类型的异常。
* try语句块对应一个catch子句。，盖子局负责处理类型为runtime_error的异常。如果try语句块的代码跑出了runtime_error异常，接下来执行catch块内的语句。在我们书写catch的子句中，输出一段提示信息要求用户指定程序是否继续。如果用户输入‘n’，执行break语句并退出while循环：否则，直接执行while循环的右侧花括号，意味着程序控制权跳回到while条件部分准备下一次迭代。
* 给用户的提示信息中输出了err.what()的返回值，我们知道err的尅形式runtime_error，因此能推断what是runtime_error类的一个成员函数每个标准库异常类都定义了名为what的成员函数，这些函数没有参数，返回值是C风格字符串(即const char*)。其中，runtime_error的what成员返回的是初始化一个具体对象时所用的string对象的副本。如果上一届编写的代码抛出异常，则本届的catch句子输出

                Date must refer to name ISBN
                Try Again?Enter y or n

### 函数在寻找处理代码的过程中退出
* 在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个try语句块，例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能调用了包含有一个try语句块的新函数，以此类推。
* 寻找处理代码的过程与函数调用链刚好相反。当一场被泡出事，首先搜索跑出该异常的函数。如果没找到匹配的catch子句，终止改哈散户，并在调用该函数的函数中继续寻找。如果没找到匹配的catch子句，终止该函数，并在调用该函数中继续寻找。如果还没找到匹配的catch子句，这个新的函数也被终止没继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。
* 如果还是没能找到任何匹配的catch子句，程序转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。
* 对于那些没有任何try语句块定义的异常，也按照类似的方法处理：毕竟，没有讨人厌语句块也就意味着没有匹配的catch子句。如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行。
* 提示：比那些异常安全的代码非常困难，异常中断了程序的正常流程。异常发生时，调用者请求的一部分计算可能已经完成，另一部分则尚未完成。通常情况下，略过部分程序意味着某些对象处理到一半就戛然而止，从而导致对象处于无效或未完成的状态，或者资源没有正常释放，等等。那些在异常发生期间正确执行了“清理”工作的程序被称作`异常安全(expection safe)`的代码。然而经验表明，编写异常安全的代码非常困难，这部分知识也（远远）超出了本书的范围。对于一些程序来说，当异常发生时只是简单地终止程序。此时，我们不怎么需要担心异常安全的问题。但是对于那些确实要处理异常并且继续执行的程序，就要加倍注意了。我们必须时刻清楚异常合适发生、异常发生后程序应该如何确保对象有效、资源无泄漏、程序处于合理状态，等等。

## 标准异常
* c++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以在用户编写的程序中使用，他们分别定义在4个头文件中。
  * expection头文件定义了最通用的异常类expection。他只报告异常的发生，不提供任何额外信息。
  * stdexpect头文件定义了几种常用的异常类，星系信息在下表列出
  * new头文件定义了bad_allc异常类型，
  * type_info头文件定义了bad_cast异常类型
![stdexcept定义的异常类](stdexcept定义的异常类.PNG)
* 标准库异常类只定义了几种运算，包括创建或拷贝异常类型的对象，以及为异常类型的对象赋值。
* 我们只能以默认出海刷的方式初始化exceotion、bad_alloc和bad_cast对象，不允许为这些对象提供初始值。
* 其他异常类型的行为则恰好想爱你规范：应该使用string对象或c风格字符串初始化这些类型的对象。但是不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该处是指含有错误相关的信息。
* 异常类型之定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向c风格字符串的const char*。该字符串的母的是提供关于异常的一些文本信息。
* what函数返回的C风格字符串的内容与异常对象的类型有关。如果异常类型有一个字符串初始值，则what返回该字符串。对于其他无处使之的异常类型来说，what返回的内容有编译器决定。