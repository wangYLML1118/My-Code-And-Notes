# C++ Primer Chapter 6:6.1-6.2参数传递
* 函数是一个命了名的代码块，我们通过调用函数执行相应的代码。函数可以有0个或多个参数。而且通常会产生一个结果。可以重载函数，也就是说，同一个名字可以对应几个不同的函数。

## 函数基础
* 一个典型的函数定义包括以下几个部分：返回类型(return type)、函数名字、有0个或多个`形参(parameter)`组成的列表以及函数体。

### 调用函数
* 函数的调用完成两个工作：一是实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，`主调函数(calling function)`的执行被暂时中断，`被调用函数(called function)`开始执行。
* 执行函数的第一步是（隐式地）定义并初始化它的形参。

### 形参和实参
* 实参是形参的初始值，第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。尽管实参与形参存在对应关系，但是并没有规定实参的求值顺序。编译器能以任意可行的顺序对实参求值。
* 实参的类型必须与对应的形参类型匹配。

### 函数返回类型
* 大多数类型都能用作函数的返回类型，一种特殊的返回类型是void，他表示函数不返回任何值。
## 局部对象
* 在c++语言中，名字有作用域，对象有`生命周期(lifetime)`理解这两个概念非常重要。
  * 名字的作用域是程序文本的一部分，名字在其中可见，
  * 对象的生命周期是程序执行过程中该对象存在的一段时间。
* 如我们所指，函数体是一个语句块，块构成一个新的作用域，我们可以再其中定义变量。形参和函数体内部定义定义的变量统称为`局部变量`。他们对函数而言是“局部”的，尽在函数的作用与内课件，同时局部变量还会`隐藏`在外层作用域中同名的其他所有声明中。
* 在所有函数体之外定义的对象存在于程序的整个执行过称重。此类对象在程序启东市被创建，直到程序结束才会销毁。局部变量的生命周期其依赖于定义的方式。

### 自动对象
* 对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当达到定义所在的块末时销毁它。我们把只存在于块执行期间的对象成为`自动对象`。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。
* 形参时一种自动独享，函数开始时为形参申请内存空间。因为形参定义在函数体作用与之内，所以一旦程序中止。形参也被销毁。
*我么用实参初始化形参对应的自动对象， 对于局部变量对应的自动对象来说，分为两种情况：如果变量定义本身含有初始值，就用这个初始值进行初始化：否则。如果变量订一本神不含初始值，执行默认初始化。这意味着内置类型的未初始化局部变量将产生未定义的值。
### 局部静态对象
* 有时候，有必要令局部变量的声明周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型从而获得这样的对象。`局部静态对象(local static object)`在程序的执行路径第一次经过对象定义语句时初始化，并且知道程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它产生影响。
* 如果局部静态变量没有显式初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。

## 函数声明
* 和其他名字一样，函数的名字必须在使用跟之前声明。类似于汴梁，函数只能定义一次，但可以声明多次。唯一的例外是，如果一个函数永远也不会被我们用到，那么我们可以只声明不定义。
* 函数的三要素（返回类型、函数名、形参类型）描述了函数的借口，说明了调用该函数所需的全部信息。函数声明也称作`函数原型(function prototype)`。

### 在头文件中进行函数声明
* 我们建议在头文件中进行变量声明。与之类似，函数也应该在头文件中声明，而在源文件中定义。
* 定义函数的源文件应该吧含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。
  * 含有函数声明的头文件应该被包含到定义函数的源文件中


## 分离式编译
* 随着程序越来越复杂，我们希望把程序的各个部分分别存储在不同文件中。为了允许编写程序是按照逻辑关系将其划分开来，c++语言支持所谓的`分离式编译(separate)`。分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。

### 编译和链接接多个源文件
* 编译器可同时编译多个源文件，直接在编译器运行指令的后边加上需要编译的源文件名即可
* 如果我们修改了其中一个源文件，那么只需重新编译那个改动了的文件。大多数编译器都提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名市.obj(windows)或.o（unix）的文件，后缀名的含义是该文件包含`对象代码(object code)`。


## 参数传递
* 每次调用函数都会重新创建它的形参，并用传入的实参对形参进行初始化。
  * 形参初始化的机理与变量初始化一样。
* 形参的类型决定了形参和实参交互的方式。如果形参时引用类型，它将绑定到对应的是参上；否则将实参的值拷贝后赋给形参。
* 当形参是引用类型时，我们说它对应的实参被`引用传递(passed by reference)`或者函数被`传引用调用(called by reference)`。和其他引用一样，引用形参也是它绑定的对象的别名；也就是说，引用形参是它对应的实参的别名。
* 当实参的值背靠背给形参是，形参和实参是两个互相独立的对象。我们说这样的实参被`值传递(passed by value)`或者函数被`传值调用(called by value)`。

## 传值参数
* 当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。传值参数的机理完全一样，函数对形参的所有操作都不会影响实参。

### 指针形参
* 指针的行为和其他非引用类型一样，当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针，因为指针使我们可以间接地访问他所指的对象的值
* 在c++中，建议使用引用类型的形参替代指针。

## 传引用参数
* 对于应用的操作实际上是作用在引用所引的对象上。
* 通过使用引用形参，允许函数改变一个或多个实参的值。

### 使用引用避免拷贝
* 拷贝大的类类型对象或容器对象比较低小，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作是，函数只能通过引用形参访问该类型的对象。
* 如果函数无需改变引用形参的值，最好将其声明为常量引用。

### 使用引用形参返回额外信息
* 一个函数只能返回一个值，引用形参为我们一次返回多个结果提供了有效的途径。
* 如何定义函数使得它既能够返回位置也返回出现次数？一种方法是定义一个新的数据类型让，他包含位置和数量两个成员，还有另一种更简单的方法，我们可以给函数传入一个额外的引用实参，令其保存字符出现的次数

### const形参和实参
* 当形参是const时，顶层const作用于对象本身，和其他初始化过程一样，当用实参初始化形参是会忽略掉东曾const。换句话说，形参的顶层const被忽略掉了。当形参有顶层const时，传给他常量对象或者非常量对象都是可以的
* c++中，可以定义若干有相同名字的函数，但是函数的形参列表应该有明显的区别。
* 
### 指针或引用形参与const
* 形参的初始化方式和变量的初始化方式是一样的。我们可以使用非常亮出事阿虎一个底层const对象，但是反过来不行；一个普通的引用必须用同类型的对象初始化。

### 尽量使用常量引用
* 把函数不会改变的形参定义成引用是一种比较常见的错误，这么做带给函数的调用者一种舞蹈，奇函数可以修改他的实参的值。此外，使用引用儿非常亮引用也会极大地限制函数所能接受的是参类型。就像刚刚看到的，我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。

## 数组形参
* 数组的两个特殊性质对我们定义和使用作用在数组的函数有影响，这两个性质分别是：不允许拷贝数组以及使用数组是会将其准换成指针。以为内不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组收元素的指针。尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式。
* 数组的大小对函数的调用没有影响。和其他使用数组的代码一样。艺术组作为形参的函数也必须确保使用数组是不会越界。
* 因为数组事宜指针的形式传递给参数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常见的技术。

### 使用标记制定数组长度
* 管理数组实参的第一种方法要求数组本身包含一个结束标记，使用这种方法的典型事例是C风格字符串。c风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。函数在处理c风格字符串时遇到空字符停止。
* 这种方法适用于那些有明显结束标记且不会与普通数据混淆的情况，但是对于向int这样所有取值都是合法值的数据就不太有效了。

### 使用标准库规范
* 管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方法收到了标准库技术的启发
* 我们使用标准库函数begin和end提供所需指针。

### 显式传递一个表示数组大小的形参
* 第三种管理数组实参的方法是专门定义一个表示数组大小的形参，在c程序和过去的c++程序中常常使用这种方法。只要传递给函数的size值不超过数组实际的大小，函数就是安全的。

### 数组形参和const
* 当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。

### 数组引用形参
* c++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上。

### 传递多维数组
* 因为我们处理的是数组的数组，所以收元素本身就是一个数组，指针就是一个指向数组的指针。数组第二位（以及后面所有维度）的大小都是数组类型的一部分。不能省略。


## main：处理命令行选项
* main函数是演示c++程序如何向函数传递数组的好例子。到目前为止，我们定义的买呢函数都只有空形参列表。
* 然而，又是我们确实需要给main传递实参，一种常见的情况是用户通过设置一组选项标确定函数所要执行的操作。


## 含有可变形参的函数
* 又是我们无法提前预知应该向函数传递几个参数，为了能编写处理不同数量实参的函数，c++11新标准提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板，
* c++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。这种功能一般只适用于与c函数交互的接口程序。

### initializer_list实参
* 如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。initializer_list类型定义在同名的头文件中。
* 和vector一样，initializer_list也是一种模板类型。定义initializer_list对象时，必须说明列表中所含元素的类型。
* 和vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。
* 作用于initializer_list对象的begin和end操作类似于vector对应的成员。begin()成员提供一个指向列表收元素的指针，end()成员提供一个指向列表尾后元素的指针。我们的函数首先初始化beg令其表示首元素，然后依次遍历列表中的每个元素。在循环体中，解引用beg以访问当前元素并输出它的值。
* 如果想initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号内、
* 含有initializer_list形参的函数也可以拥有其他形参。


### 省略符形参
* 省略符形参是为了便于c++程序访问某些特殊的c代码而设置的，这些代码使用了名为varargs的c标准库工鞥。通常，省略符形参不应用于其他目的。
* 省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎两种：

        void foo(parm_list,...);
        void foo(...);
* 第一种形式制定了foo函数的部分形参的类型，对于这些形参的实参将会执行正常的类型检查。省略符形参所对应的实参无需类型检查。在第一种形式中，形参声明后面的逗号是可选的。



## 返回类型和return语句
* return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。

## 无返回值函数
* 没有返回值的return语句只能用在返回类型是void函数中，返回void的函数不要求非得有return语句，因为在这类函数的最后一句会隐式地执行return。
* 一个返回类型是coid的函数也能使用return语句的第二种形式，不过此时return语句的expression必须是一个返回void的函数。强行领void函数返回其他类型的表达式将产生编译错误。

## 有返回值函数
* 只要函数的返回类型不是void，则该函数内的你每一条return语句必须返回一个值。return语句返回值的类型必须与函数的返回类型相同，或者能够隐式地转换成函数的返回类型。
* 尽管c++无法确保结果的正确性，但是可以保证每个return语句的结果类型正确。也许无法估计所有情况，但是编译器仍然尽量确保其具有返回值的函数只能通过一条于晓的return语句退出。

### 只是如何被返回的
* 返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。
* 必须注意的是当函数返回局部变量时的初始化规则。
* 同其他引用类型一样，如果函数返回引用，则该引用仅是它所引对象的一个别名。

### 不要反悔局部对象的引用或指针
* 函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将不再指向有效的内存区域。
* 返回局部对象的引用时错误的：同样返回局部对象的指针也是错误的。一旦函数完成，局部对象被释放，指针将指向一个不存在的对象。

### 返回类类型的函数和调用运算符
* 和其他运算符一样，调用运算符也有优先级和结合律。调用运算符的优先级与点运算符何建投员孙福相同，并且也复合做结合律。因此，如果函数返回指针、引用或类的对象，我们能使用函数调用的结果访问结果对象的成员。

### 引用返回左值
* 函数返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右値。可以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数结果赋值。
* 把函数调用放在赋值语句的左侧可能看起来有点奇怪，但其实这没什么特别的。返回之时饮用，因此调用是个左值。和其他左值一样它也能出现在赋值运算符的左侧。
* 如果返回类型是常量引用，我们不能给调用的结果赋值，这一点和我们熟悉的情况是一样的。


### 列表初始化返回值
* c++11新标准规定，函数可以返回花括号保卫的值的列表。类似于其他返回结果，此处的类别奥也用来对表示函数返回的淋适量进行出事阿虎。如果列表为空，淋适量执行出事阿虎；否则，返回的值有函数的返回类型决定。
* 如果函数返回的是内置类型，则花括号包伟德列表最多包含一个值，而且改值所占空间不应该大于目标类型所占空间。如果函数返回的是类类型，由类本身定义初始值如何使用。

### 主函数main的返回值
* 我们允许买呢函数没有return语句直接结束。如果控制到达了main函数的结尾处而没有return语句，编译器将隐式地插入一条返回0的return语句。


### 递归
* 如果一个函数调用了它自身，不管这中调用是直接的还是间接的，都成该函数是`递归函数(recusive sunction)`。
* 在递归函数中，一定有某条路径是不包含递归调用的；否则，函数将“永远”递归下去。换句话说，函数将不断地调用它自身知道程序栈空间耗尽为止。我们有时候会说这种函数含有`递归循环(recursion loop)`。

## 返回数组指针
* 因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。虽然从语法上来说，要想定义一个返回数组的指针或引用的函数比较繁琐，但是有一些方法可以简化这些任务，其中最直接的方法是使用类型别名

### 声明一个返回数组指针的函数
* 要想在声明func是不使用类型别名，我们必须牢记北定能够以的名字后面数组的维度
* 和这些声明一样，如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该咸鱼数组的维度。


### 使用位置返回类型
* 在c++11新标准中还有一种可以简化上述func声明的方法，就是使用`尾置返回类型(trailing return type)`。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表制后，我们在本应该出现返回类型的地方放置一个auto；
* 因为我们把函数返回类型放在了形参列表之后，所以可以清楚地知道函数返回的是什么。


### 使用decltype
* 还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。

##函数重载
* 如果同一作用于内的结果函数名字相同但是形参列表不同，我们称之为`重载函数(overloaded)`。
* 这写函数接受的形参类型不一样，但是执行的操作非常类似。当调用这写函数式，编译器会根据传递的是参类型推断出想要的是哪个函数
* 函数的你半个字仅仅是让编译器直到它调用的是呢个韩束么函数重载可以在一定程度上减轻程序员起名字、记名字的负担。main函数不能重载。

### 定义重载函数
* 有一种典型的数据库应用，需要穿件几个不同的函数分别根据名字、电话、账户号码等信息查找记录。函数重载可以使得我们定义一组函数。它们的名字都是lookup，但是查找的一句不同。
* 对于重载的函数来说，他们应该在形参数量或形参类型上有所不同。在上面的代码中，虽然每个函数都只接受一个参数，但是参数的类型不同。
* 不允许两个函数除了返回类型外其他所有要素都相同。

### 判断两个形参的类型是否相异
* 在一堆声明中，第一个函数给它的形参起了名字，第二个函数没有。形参的名字仅仅起到帮助记忆的作用，有没有它并不影响形参列表的内容。

### 重载和const形参
* 顶层const不影响传入函数的对象，一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来，
* 另一方面，如果形参是某种类型的指针或者引用，则通过区分气质像的是常量对象还是非常亮对象可以实现函数重载，此时const是底层的。

### 调用重载的函数
* 定义了一组重载函数后，我们需要以合理的是惨调用他们。`函数匹配(function matching)`是指一个过程，在这个过程中我们把函数调用与异族重载函数中的某一个关联起来，函数匹配也叫作`重载确定(overloaded resolution)`。编译器首先将调用的实参与重载集合中没一个函数的心颤进行比较，然后根据比较的结果决定到底调用那个函数。

## 重载与作用域
* 一般来说，将函数生命之于局部作用域内部是一个名字的选择，但是为了说明作用域和重载的相互关系，我们将暂时违反这一原则而使用局部函数声明。
* 其实重载对作用于的一般性质并没有什么改变；如果我们在内层作用域中声明名字，它将隐藏外层作用雨中声明的同名实体。在不同的作用域中无法重载函数名。外层声明将被隐藏。


## 特殊用途语言特性
### 默认实参
* 某些函数有这样一种形参，在函数的很多次调用中他们都被赋予一个相同的值，此时，我们把这个反复出现的值称为`默认实参`。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。

### 使用默认实参调用函数
* 如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。函数调用时，实参按照其位置解析，默认是残负责填补函数缺少的韦布实参（靠右位置），

### 默认实参声明
* 对于函数的生命来说，通常的习惯是将其放在头文件中，并且一个函数之生命一次，但是多次声明同一个函数䦹合法的。不过一点需要注意，在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧所有形参必须都有默认值。

### 默认是残初始值
* 局部变量不能作为默认实参。初次之外，只要表达的类型能转换成形参所需的类型，该表达式就能作为默认实参。
* 用作默认的名字在函数声明所在的作用于内解析，而这些名字的求值过程发生在函数调用时


## 内联函数和constexpr函数
*把规模较小的操作定义成韩束有很多好处，比如：

        阅读和理解函数调用要不读懂等价的条件表达式要比读懂等价的条件表达式容易得多。
        使用函数可以确保行为的同一，每次相关操作都能保证按照相同的方式进行。
        如果我们需要修改计算过程，显然修改函数要比先找到等价表达式所出现的地方再逐一修改更容易。
        函数可以被其他应用重复利用，省去了程序员冲寻编写的代价。

* 然而，使用函数也存在一个潜在的缺点：调用函数一般比丘等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回是恢复；可能需要拷贝时残；程序准想一个新的位置继续执行。

### 内联函数可以避免函数调用的开销
* 将函数指定为`内联函数(inline)`，通常就是将它在某个调用电商“内联”地展开。
* 在函数的返回类型前加上inline就可以将它声明为内联函数
* 一般来说，内联机制用于优化规模较小、流程志杰、频繁调用的函数。很多编译器都不支持内联递归函数，而且一个75行的函数也不大可能在调用点内联地展开。

### constexpr函数
* `constexpr函数`是指能用于常量表达式的函数。定义constexpr函数的方法与其它函数类似，不过要遵循几项规定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。
* constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。例如，constexpr函数中可以有空语句、类型别名以及using声明。

### 把内联函数和constexpr函数放在头文件中
* 和其他函数不一样，内联函数和constexpr函数可以再程序中多次定义。毕竟，编译器要想展开函数仅有函数声明是不够的，还需要函数的定义。不过，对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。

## 调试帮助
* c++程序员有事会用到一种头文件保护的技术，以便有选择地执行调试代码。接本思想是，程序可以包含一些用于调试的代码，但是这些代码只有在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert和NDEBUG。

### assert预处理宏
* assert是一种`预处理宏`。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件：

        assert(expr);
* 首先对expr求值，如果表达式为加（即0），assert输出信息并终止程序的执行。如果表达式为真，assert什么也不做。
* assert宏定义在cassert头文件中。预处理名字由预处理器而非编译器管理，因此我们可以直接使用预处理名字而无需提供using声明。也就是说，我们应该使用assert而不是std：：assert，也不需要为assert提供using声明。
* 和预处理变量一样，宏名字在程序内必须唯一。含有cassert头文件的程序不能再定义名为assert的变量、函数或其他实体。在世纪变成过程中，即使我们没有包含cassert头文件，也最好不要为了其他目的使用assert。很多头文件都包含了额cassert。有可能会间接包含cassert。
* assert宏通常用于检查不能发生的条件。

### NDEBUG预处理宏
* assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG。则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。
* 我们可以使用define语句定义NDEBUG，从而关闭调试状态。
* 定义NDEBUG能避免检查各种条件所需的云像是开销，当然此时根本不可能回执性运行时检查，因此assert应该仅能用于验证那些确实不可能发生的事情。我们可以吧assert当成调试程序的一种手段牡丹石不能用它代替真正的运行时逻辑检查，也不能代替程序本身应该包含的错误检查。

## 函数匹配
* 大多数情况下，我们容易确定某次调用应该选用哪个重载函数。然而，当几个重载函数的形参数量相等以及某些形参的类型可以由其他类型转换得来时，这项工作就不呢么容易了。

### 确定候选函数和可行函数
* 函数匹配的第一步是选定本次调用相应的重载函数集，集合中的函数称为`候选函数(candidate function)`。可行函数也有两个特性：一是与背调用的函数同名，二是其声明在调用点可见。
* 第二步考察本次调用提供的参数，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为`可行函数(viable function)`。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等。二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。
* 如果没找到可行函数，编译器讲报告无匹配函数的错误。

### 寻找最佳匹配（如果有的话）
* 函数匹配的第三部是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找星灿类型与实参类型最匹配的那个可行函数。

### 含有多个形参的函数匹配
* 当实参的数量有两个或更多时，函数匹配就比较复杂了。
* 选择可行函数的方法和只有一个实参时一样，编译器选择那些形参数量满足要求且实参类型和形参类型能够匹配的函数。
* 如果编译器因为调用的二义性拒绝请求，说明程序设计有问题（我们的形参集合不合理）。


## 实参类型转换
* 为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示：

        1、精确匹配包含以下情况：
            * 实参类型和形参类型相同
            * 实参从数组类型或函数类型转换成对应的指针类型。
            * 像是餐添加顶层cosnt或者从实参中删除顶层const
        2、通过const转换实现的匹配
        3、通过类型提升实现的匹配
        4、通过算术类型转换
        5、通过类类型转换实现的匹配


### 需要类型提升和算术类型转换的匹配
* 内置类型的提升和转换可能在函数匹配时产生意想不到的结果，但幸运的是，在设计良好的系统中函数很少会含有这样的形参。
* 分析函数调用前，我们应该知道小正兴一般都会提升到int类型或更大的整数类型

### 函数匹配和const实参
* 如果重载函数的区别在于他们的引用类型的形参是否引用了const，或者指针类型的形参是否指向const，则当调用发生时编译器通过实参是否是常量来决定选择哪一个函数
* 指针累心搞得形参也累死。如果两个函数唯一区别是它的指针形参指向常量或非常量，则编译器能通过实参是否是常量决定用哪个函数；如果实参是指向常量的指针，调用形参是const*函数；如果实参是指向非常量的指针，调用形参是普通指针的函数。 

## 函数指针
* 函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。：

                //比较两个string对象的长度
                bool lengthcompare(const string &,const string &)
* 该函数的类型是bool(const string &,const string &)。要想生命一个可以指向该函数的指针，只需要用指针替换函数名即可：

                //pf指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型
                bool(*pf)(const string &.const string &);//未初始化
* 从我们声明的名字开始观察，pf前面有个* ，因此pf是指针；有测试形参列表，表示pf指向的势函数；在观察左侧，发现函数的返回类型是布尔值。因此，pf就设计一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。

                *pf两端括号必不可少，否则pf变为一个返回值为bool指针的函数

### 使用函数数指针
* 当我们把函数名作为一个值使用时，该函数自动转换成指针。
* 我们还能直接使用指向函数的指针调用该函数，无需提前解引用指针。
* 在指向不同函数类型的指针间不存在转换规则。但是和往常一样，我们可以为函数指针赋一个nullptr或者值为0的整型常量表达式，表示该指针没有指向任何一个函数

### 重载函数的指针
* 当我们使用重载函数时，上下文必须清晰地界定到底应该选用那个函数。如果定义了指向重载函数的指针
* 编译器通过指针类型决定选用那个函数，指针类型必须与重载函数中的某一个精确匹配。

###函数指针形参
* 和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用，函数会自动传换成指针。
* 直接使用函数指针类型显得冗长而烦琐。类型别名和decltype能让我们简化使用了函数指针的代码。

### 返回指向函数的指针
* 和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要想生命一个返回函数指针的函数，最简单的办法是使用类型别名。
* 出于完整性考虑，我们还可以使用位置但会类型的方式

### 将auto和decltype用于函数指针类型
* 如果我们明确知道返回的函数是哪一个，就能使用decltype简化书写函数指针返回类型的过程。
* 当我们将decltype作用于某个函数时，他返回函数类型而非指针类型。因此我们显式地加上*以表明我们需要返回指针，而非函数本身。