# C++ Primer Chapter4:表达式4.1-4.4
* 表达式有一个或多个`运算对象（operand）`组成，对表达式求职将得到一个`结果（result）`,字面值和变量是最简单的`表达式(expression)`，其结果就是字面值和变量的值。把一个`运算符（operator）`和一个或多个运算对象组合起来可以生成较复杂的表达式。
## 基础
* c++定义了`一元运算符（unary operator）`和`二元运算符（binary operator）`。作用于一个运算对象的运算符是一元运算符，如取地址符（&）、和解引用符( * )；作用于两个运算对象的运算符是二元运算符，如相等运算符（==）、和乘法运算符（ * ）、还有一个作用于三个运算对象的三元运算符。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。一些符号既能作为一元运算符，也能作为二元运算符，以符号 *为例，作为一元运算符时执行解引用操作，作为二元运算符时执行乘法操作。一个符号到底是一元运算符还是二元运算符由它的上下文决定。对于这类符号来说，他的两种用法互不相干，完全可以当成两个不同的符号。
### 组合运算符和运算对象
* 对于含有多个运算符的复杂表达式来说，要想理解它的含义首先要理解运算符的优先级(precedence)、结合律(associativity)以及运算对象的求职顺序(order of evalution)。例如，下面这条表达式的求职结果依赖于表达式中运算符和运算对象的组合方式。
### 运算对象转换
* 在表达式求职过程中，云撒UN对象啊ing常常有一种类型转换成另外一种类型。例如，尽管一般的二元运算符都要求两个运算对象的类型相同，但是很多时候及时运算对象的类型不相同也没关系，只要他们能被转换成同一种类型即可。
* 整数和浮点数能互相转换，但是指针不能转换成浮点数。小整数类型通常会被提升成较大的整数类型。
### 重载运算符
* c++语言定义了运算符作用于内置类型和复合类型运算对象是所只想的操作。当运算符作用于类类型的运算对象时。用户可以自行定义其含义。因为这种自定义的过程事实上是为已存在的运算符赋予了另外一种含义，之所以称之为`重载运算符（overloaded operator）`。IO库的>>和<<运算符以及string对象、vector对象和迭代器使用的运算符都是重载运算符。使用重载运算符时，其包括运算对象的额立新和返回值的类型，都是由该运算符定义的：但是运算对象的个数、预算符的优先级和结合律都是无法改变的。

### 左值和右値
* c++的表达式要不然是右値，要不然是左值。这两个名词是从c语言继承过来的，原本是为了帮助记忆：左值可以位于赋值语句的左侧，右値则不能。
* 在c++语言中，二者的区别就没那么简单了。一个左值表达式的球直接过是一个对象或者一个函数，然而以擦很难过梁对象为代表的某些坐直是加上不能作为赋值语句的左侧运算对象。此外，虽然某些表达式的求值结果是对象，但他们是右値而非左值。可以做一个简单的归纳：当一个对阿星被用作右値的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。
* 不同的运算符对运算对象的要求各不相同，有的需要左值运算对象、有的需要右値运算对象；返回值也有差异。一个重要原则是在需要右値的地方可以使用左值来代替，但是不能把右値当成左值（也就是位置）使用。当一个左值被当做右値使用时，实际使用的是他的内存（值）。到目前为止，已经有几种我们熟悉的运算符是要用到左值的。
  * 赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果仍然是一个左值。
  * 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针式一个右値。
  * 内置解引用运算符、下标运算符、迭代器解引用符、string和vector的下标运算符的求值结果都是左值。
  * 内置类型和迭代器的递增递减运算符作用于左值运算对象。
* 使用关键字decltype的时候，作之和右値也有所不同。如果表达式的求值结果是做之mdecltype作用于该表达式（不是变量）的到一个引用类型。举个例子，假定p的类型是int*，因为解引用运算符生成左值，所以decltype(*p)的结果是int&,另一方面，因为取地址运算符生成右値，所以decltype的结果是int**，也就是说，结果是一个指向整型指针的指针。

### 优先级与结合律
* `复合表达式（compound expression）`是指含有两个或多个运算符的表达式。求复合表达式的值需要首先将运算符和运算对象合理地组合在一起，优先级与结合律决定了运算对象的组合方式。括号可以无视上述规则。
* 一般来说，表达式最终的值依赖于其子表达式的组合方式，如果优先级相同则其组合规则由结合律确定。算术运算符满足左结合律，如果优先级相同，将按照从左向右的顺序组和运算对象：

        根据运算符的优先级，表达式3+4*5的值是23，不是35；
        根据运算符的结合律，表达式20-15-3的值是2，不是8
### 括号无视优先级于结合律
* 括号无视普通的组合规则，表达式中括号括起来的部分备档成一个单元来求职，然后再与其他部分一起按照优先级组合。

### 优先级与结合律有何影响
* 优先级会影响程序的正确性，这在之前介绍的解引用和指针运算中有所体现:

        int ia[]={0,2,4,6,8};//含有5个整数的数组
        int last=*(ia+4);//把last初始化成8也就是ia[4]的值
        last=*ia+4；//last=4，等价于ia[0]+4
* 如果想访问ia+4位置的元素，那么加法运算两端的括号必不可少。一旦去掉这对括号，*ia就会首先组合在一起，然后4在与 *ia的值相加。

### 求值顺序
* 优先级规定了运算对象的组合方式，但没有说明运算对象按照什么顺序求职。在大多数情况下不会明确制定求职的顺序。
* 对于那些没有指定顺序的运算符来说，如果表达式指向并修改了同一对象，将会引发错误并产生未定义的行为。举个简单的例子，<<运算符没有明确规定何时以及如何对运算对象求值。
* 有四种运算符明确规定了运算对象的求值顺序。第一种是逻辑与运算符（&&），它规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值。另外三种分别是逻辑或（||）、条件运算符（？：）和逗号（,）运算符。

### 求值顺序、优先级、结合律
* 有云撒UN对象啊ing的求值顺序与优先律无关，在一条形如f()+g()*h()+j()的表达式中：

        优先级规定，g（）的返回值和h（）的返回值相乘
        结合律规定，f（）的返回值咸鱼g（）和h（）的成绩相加，所得结果再与j（）的返回值相加。
        对于这些函数的调用顺序没有明确规定
*如果f、g、h和j事务官韩束，他们既不会改变同意对象的状态也不执行io任务，那么函数的调用顺序不受限制。繁殖，如果其中某几个函数影响同一对象，则他是一条错误的表达式，将产生未定义的行为。

        处理复合表达式
        1、拿不准的时候最好用括号让表达式的组合关系复合程序逻辑的要求
        2、如果改变了一个运算对象的值，在其他区地方不要再使用此运算对象

## 算术运算符
* 算术运算符都能作用于任意算术类型，以及任意能转换为算数类型的类型。算术运算符对的运算对象和求值结果都是右値，所有的运算对象最终都会转换成一种类型
* 一元正号运算符、加法运算符、和减法运算符否能作用于指针。当一元正号运算符作用于一个对阿星或者算术值时，则返回运算对象值的一个（提升后的）副本。
* 对大多数运算符来说，布尔类型的云撒UN对象啊ing将被提升为int类型。

        溢出和其他运算符异常
        算术表达式有可能产生未定义的结果。一部分原因是数学性质本身：例如除数为0的情况；另外一部分则源于计算机的特点：例如溢出，当计算的结果超出该类型所能表示的范围时就会产生溢出。

* 在除法运算中，如果两个对象的符号相同则商为正（如果不为0的话），否则商为负。c++语言的早期版本允许结果为负值的商向上或向下取证，c++11新标准则规定商一律向0取整。
* 根据取余运算的定义，如果m和n是整数且n非0，则表达式（m/n）*n+m%n的求值结果与m相等。

## 逻辑和关系运算符
* 关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算符和关系运算符的返回值都是布尔类型。值为0的运算对象（算数类型或指针类型）表示加，否则表示真。对于这两类运算符来说，运算对象和求值结果都是右値。

### 逻辑与和逻辑或运算符
* 对于逻辑与运算符（&&）来说，当且仅当两个运算独享都为真时结果为真；对于逻辑或运算符（||）来说，只要两个运算对象的一个为真结果就为真。
* 逻辑与运算符和逻辑或运算符都是先求左侧云撒UN赌侠ing的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果是才会计算右侧运算对象的值。这种策略称为`短路求值(short-circuit evaluation)`。
  * 对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值
  * 对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值

### 逻辑非运算符
* 逻辑非运算符（！）将运算对象的值取反候返回，之前我们使用过这个运算符。

### 关系运算符
* 顾名思义，关系运算符比较运算对象的大小关系并返回布尔值。关系运算符都满足左结合律。
* 因为关系运算符的求值结果是布尔值，所以讲几个关系运算符连写在一起会产生意想不到的结果；

### 相等性测试与布尔字面值
* 如果想测试一个算术对象或指针对象的真值，最直接的方法就是将其作为if语句的条件：

        if(val) {/*...*/}   //如果val是任意的非0值，条件为真
        if(!val) {/*...*/}  //如果val是0，条件为真
* 在上面的两个条件中，编译器都将cal转换成布尔值。如果val非0则第一个条件为真，如果val的值为0则第二个条件为真。
* 如果val不是布尔值，可将程序改写成下面的形式：

        if(val==1) {/*...*/}

* 进行比较运算时除非比较的对象时布尔类型，否则不要使用布尔字面值true和false作为运算对象

## 赋值运算符
* 赋值运算符的左侧运算对象必须是一个可修改的左值，如果给定：

        int i=0,j=0,k=0;//初始化而非赋值
        const int ci=i;//初始化而非赋值
* 则下面赋值语句都是非法的

        1024=k;//错误：字面值是右値
        i+j=k;//错误：算术表达式是右値
        ci=k;//vi现在含有10个元素了，只从0到9
* 赋值运算符的结果是它的左侧运算对象，并且是一个左值。相应的，结果的类型就是左侧运算对象的类型。如果赋值运算符的左右两个运算符对象类型不同，则右侧运算符对象将转换成左侧运算对象的类型：

        k=0;//结果：类型是int，值是0
        k=3.14159;//结果：类型是int，值是3
* c++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象。
* 如果左侧运算对象是内置类型，那么初始值列表最多只能包含一个值，而且该值即使转换的话其所占空间也不应该大于目标类型的空间。
* 对于类类型来说，赋值运算的细节由类本身决定。对于vector来说，vector模板重载了赋值运算符并且可以接受初始值列表，当赋值发生时用右侧运算对象的元素替换左侧运算对象的元素。
* 无论左侧运算对象的类型是什么，初始值列表都可以为空。此时，编译器创建一个值初始化的淋适量并将其赋给左侧运算对象。

### 赋值运算满足右结合律
* 赋值运算符满足右结合律，这一点与其他二元运算符不太一样:

                int jval,ival;
                ival=jval=0;//正确，都被赋值为0

* 因为赋值运算符满足右结合律，所以靠右的赋值运算jval=0作为靠左的赋值运算符的右侧运算对象。。又因为赋值运算返回的是其一左侧运算独享，所以靠右的赋值运算的结果（即jval）被赋给了ival。
* 对于多重赋值语句中的每一个对象，他的类型或者与右边对象类型相同、或者可由右边对象的类型转换得到：

                int val,*pval;//ival的类型是int，;pval是指向int的指针
                ival=pval=0;//错误：不能把指针的值赋给int
                string s1,s2;
                s1=s2="OK";//字符串字面值“OK”转换成string对象
* 因为ival和pval的类型不同，而且pval的类型(int*)无法转换成ival的类型（int），所以尽管0这个值能赋给任何对象，但是第一条语句仍然是非法的。与之相反，第二条赋值语句是合法的，这是因为字符串字面值可以转换成string对象，并赋给s2，而s2和s1的类型相同，所以s2的值可以继续赋给s1。

### 赋值运算优先级较低、
* 赋值语句经常会出现在条件当中，因为赋值运算的优先级相对较低，所以通常需要给这一部分加上括号，使其符合我们的原意。下面这个循环说明了吧赋值语句放在条件当中有什么用处，他的目的是反复调用一个函数直到返回期望的值为止：

                //这是一种形式繁琐、容易出错的写法
                int i=get_value();//得到一个值
                while(i!=42)
                {
                        //其他处理。。。
                        i=get_value();//得到以下的值。
                }

* 在这段代码中，首先调用get_value函数得到一个值，然后循环部分使用该值作为条件，在循环体内部，最后一条语句会再次调用get_value函数并不断重复循环。可以将上述代码以更简单的直接的形式表达出来：

                int i;
                //更好的写法，条件部分表达得更加清晰
                while((i=get_value())!=42)
                {
                        //其他处理。。。
                }

* 这个版本的while条件更容易表达我们的真实意图：不断循环读取数据直至遇到42为止。其处理过程首先是将get_value函数的返回值赋给1，然后比较i和42是否相等。

### 切勿混淆相等运算符和赋值运算符
* c++语言允许使用赋值运算符作为条件，但是这一特性可能带来意想不到的结果；

                if(i=j)
* 此时if语句的条件部分把j的值赋给i，然后检查复制的结果是否为真。如果j不为0，条件将会为真。然而程序的初衷很可能事项判断i和j是否相等：

                if(i==j)

* 程序的这种缺陷显然很难被发现，好在一部分编译器会对类似的代码给出警告信息。

### 复合赋值运算符
* 我们经常需要对某一对象进行操作之后再把值赋给此对象，这种符合操作不光对加法来说很常见，任意一种复合运算符都完全等价于`a=a op b`。
* 唯一的区别是左侧运算对象的求值次数；使用符合运算符只求值一次，使用普通的运算符则求值两次，依次是作为右边子表达式的一部分求值，另一次是作为赋值运算符的左侧运算对象求值。其实在很多地方，这种区别除了对小程序性能有些许影响外几乎可以忽略不计。