## 最小生成树问题

### 什么是最小生成树（Minimum Spanning Tree）
* 是一棵树
  * 无回路
  * |v|个顶点一定有|v|-1条边
* 是生成树
  * 包含全部顶点
  * |v|-1条边都在图里
* 边的权重和最小

* 最小生成树存在说明图是连通的

### 贪心算法
* 什么是贪：每一步都要最好
* 什么是好：权重最小的边
* 需要约束
  * 只能用图里有的边
  * 只能正好用掉|v|-1条边
  * 不能有回路
![有权图（v3为源点）](prime算法.png)
#### prime算法——让一棵小树长大(比较适合稠密图)
  
        void prime(void)
        {
            MST={s};
            while(1)
            {
                V=未收录顶点中dist最小者
                if(这样的V不存在)
                {
                    break;
                }
                else
                {
                    将V收录进MST
                }
                for(v的每个邻接点W)
                {
                    if(W未被收录)
                    {
                        if(E(V,M)<dist[W])
                        {
                            dist[W]=E(V,M);
                            parent[W]=V;
                        }
                    }
                }
            }
        }

#### kruskal算法——将森林合并成树

        void kruskal(Graph G)
        {
            MST={};
            while(MST中不到|V|-1条边&&中还有边)
            {
                从E众取一条权重最小的边(V,E);//最小堆
                将E(V,W)从E中删除;
                if(E(V,W)不在MST中构成回路)//并查集
                {
                    将E(V,W)加入MST
                }
                else
                {
                    彻底无视E(V,W);
                }
            }
        }
