# Y86-64的熟悉怒实现
* 我们现在已经有了实现Y86处理器所需要的不见，。首先，我们描述一个成为SEQ的处理器。每个始终周期上，SEQ执行处理一条完整指令所需的所有步骤。不过这需要一个很长的始终周期时间，因此始终周期频路会低到不可接受。我们开发SEQ的目标就是提供实现最终目的的第一步，我们的最终目的是实现一个搞笑的、流水线花的处理器。


## 将处理组织成阶段
* 通常嘎哈那个，处理一条指令包括很多操作。将他们组织成某个特殊的截断序列，即使指令的动作差异很大，但所有的指令都遵循统一的序列。每一步的具体处理取决于正在执行的指令。创建这样一个框架，我们就能设计一个充分利用硬件的处理器。下面是关于各个截断以及个截断内执行操作的简略描述：
  * 取指：去直接断从内存读取指令字节，地址为程序计数器的值。从指令中抽取出指令符字节的两个四位部分，成为icode(指令代码)和ifun（指令功能）。它可能取出一个寄存器指令符字节，知名一个或两个寄存器操作数指示符rA和rB。它还可能取出一个四字节常数字calC。它按顺序方式计算当前指令的下一条指令的地址valP。也就是说，valP等于PC的值加上已取出指令的长度。
  * 译码：译码截断从寄存器文件读入最多两个操作数，得到值valA和valB，通常，它读入指令rA和rB字段指明的寄存器，不过有些指令是读寄存器%rsp的。
  * 执行：在执行截断，算术\逻辑单元（ALU）要么执行指令致命的操作（根据ifun的值），计算内存引用的有效地址，要么增加或减少栈指针。得到的值我们成为valE。在此，也可能设置条件码。对一条条件传送指令来说，这个截断会检验条件码和传送条件（由ifun给出），如果条件成立，则更新目标存储器。同样，对一条跳转指令来说，这个截断会决定是不是应该选择分之。
  * 访存：方寸截断可以讲数据写入内存，或者从内存读入数据。独处的值为valM。
  * 写回：邪乎截断最多可以两个结果到寄存器文件。
  * 更新PC：将PC设置成下一条指令的地址。
* 处理器无线循环，执行这些截断。在我们简化的视线中，发生任何宜昌市，处理器就会停止：他执行halt指令或非法指令，或它试图读或写非法地址。在更完整的设计中，处理器会进入异常处理模式，开始执行有异常的类型决定的特殊代码。
* 执行一条指令是需要进行跟多处理的。我们不仅必须执行指令所标明的操作，还必须计算地址、更新栈指针，以及确定下一条指令的地址。型号每条指令的整个流程都比较想死。因为我们像是硬件数量尽可能少，并且最终把它映射到一个二维的集成电路芯片的表面，在涉及硬件是，一个非常简单而已知的结构式非常重要的。降低复杂度的一种方法是让不同的指令共享尽量多的硬件。例如，我们的每个处理器设计都只含有一个算术\逻辑单元，根据所执行的指令类型的不同，它的使用方式也不同。在硬件上赋值逻辑块的成本比软件中有重复代码的成本大的多。而且在硬件系统中处理许多特殊情况和特性要比软件来处理困难得多。


## SEQ硬件结构
* 实现所有所有Y86指令所需要加计算可以被组织成6个基本截断：取指、译码、执行、访存、写回和更新PC。途中给出了一个能执行这些计算的硬件结构的抽象表示。程序计数器放在寄存器中。图中的左下角（标明为PC）。然后，信息沿着线流动（多条线组合在一起就用宽一点的线来表示），先向上，再向右。通各个阶段相关的硬件单元负责执行这些处理。在右边，反馈线路乡下，包括要写到寄存器文件的更新值，以及更新的程序计数器值。在SEQ中，所有硬件单元的处理都在一个时钟周期内完成。这张图省略了一些小的组合逻辑块。还省略了所有用来操作各个硬件单元以及将相应的值路由到这些单元的控制逻辑。
* 硬件单元与各个处理阶段相关联。
  * 取指：坚持个好年新股计数器寄存器作为地址，指令内存读取指令的字节。PC增加其计算valP，既增加了程序计数器
  * 译码：寄存器文件有两个读端口A和B，从这两个端口同时读寄存器值valA和valB
  * 执行：执行阶段会根据指令的类型，将算数/逻辑单元（ALU）用于不同的目的。对整数操作，它要执行指令所指定的运算。对其他指令，它会作为一个加法器来计算增加或减少栈指针，或者计算有效地址，或者只是简单地加0，讲一个输入传递到输出。条件码寄存器（CC）有三个条件码位。ALU负责计算条件吗的心智。当执行条件传送指令时，根据条件码和传送条件来计算决定是否更新目标寄存器。同样，当执行一条跳转指令时，会根据条件码和跳转类型来计算分之信号Cnd。
  * 访存：在执行访存操作时，数据内存读入或写出一个内存自。指令和数据内存访问的相同的内存位置，但是用于不同的目的。
  * 写回：寄存器文件有两个端口。端口E用来写ALU计算出来的值，二端口M用来写入数据内存中读出的值。
  * PC更新：程序计数器的新值选择自：valP，下一条指令的地址；valC，调用指令或跳转指令指定的目标地址；valM，从内存读取的返回地址。
![SEQ抽象视图.PNG](SEQ抽象视图.PNG)
![SEQ硬件结构.PNG](SEQ硬件结构.PNG)
* 图4-23给出了更详细的实现SEQ所需要的硬件（分析每个阶段是，我们会看到完整的细节）。我们看到一组和前面一样的硬件单元，但是现在线路看得更清楚了。这幅图的画图惯例：
  * 白色方框表示始终寄存器。程序计数器PC是SEQ中唯一的始终寄存器。
  * 浅蓝色方框表示硬件单元。这包括内存、ALU等等。在我们所有的处理器实现中，都会使用这一组基本单元。我们把这些单元当做“黑盒子”,不关心它们的细节设计。
  * 控制逻辑块用灰色圆角举行表示。这些快用来从一组信号源中进行选择，或者用来计算一些布尔函数。我们会非常详细地分析这些快，包括给出HCL描述。
  * 线路的名字在白色圆圈中说明。他们只是线路的表示，而不是什么硬件单元。
  * 宽度为字长的数据连接用中等粗度的线。每条这样的县实际上都代表一簇64根线，并列得；连接在一起，讲一个字东硬件的一个部分传送到另一个部分。
  * 宽度为字节或更窄的数据连线用细线表示。根据线上要携带的值的类型，每条这样的线实际上都代表一簇4或8根线。
  * 单个位的链接用虚线表示。这代表芯片上单元与块之间传递的控制值。

## SEQ的时序
* 图4-23中硬件结构的操作运行根本完全不同，一个始终变化会引发一个经过组合逻辑的流，来执行整个指令。
* SEQ的实现包括组合逻辑和两种存储设备：时钟寄存器(程序计数器和条件码寄存器)，随机访问存储器（寄存器文件、指令内存和数据内存）。组合逻辑不需要任何时序或控制——只要输入变化了，织就通过逻辑门网络传播。正如提到过的那样，我们也将读随机访问存储器看成和组合逻辑一样的操作，根据地址输入产生输出字。对于较小的存储器来说（例如寄存器文件），这是一个合理的假设，而对于较大的电路来说，可以用特殊的时钟电路来模拟这个效果，由于指令内存用来杜志玲，因此我们可以将这个单元看成是组合逻辑。
* 现在还剩四个硬件单元需要对他们的时序进行明确的控制——程序计数器、条件码就存器、数据内存和寄存器文件。这些单元通过一个时钟信号来控制，它触发将新值装载到寄存器以及将值写到随机访问存储器。每个时钟周期，程序计数器都会装载新的指令地址。只有在执行证书运算指令时，才会装载条件码寄存器。只有在执行rmmovq、pushq或call指令时，才会写数据内存。寄存器文件的两个写端口允许每个时钟周期更新两个程序寄存器，不过我们可以用特殊的寄存器ID-xF作为端口地址，来表明在此端口不应该执行写操作。
* 要控制处理器中活动的时序，只需要寄存器和内存的始终控制。硬件获得了赋值顺序执行一样的效果，即使所有的状态更新实际上同时发生，且只在始终上升开始下一个周期时。之所以能保持这样的等价性，是由于Y86指令集的本质，因为我们遵循以下原则组织计算。

        原则：从不回读
        处理器从来不需要为了完成一条指令的执行而去读又该指令更新了的状态。
* 这条原则对实现的成功来说至关重要。为了说明问题，假设我们对pushq指令的实现试讲%rsp减8，再讲更新后的%rsp值作为写操作的地址。这种方法同前面所说的那个原则相违背。为了执行内存操作，它需要先从寄存器文件中读更新过的栈指针。然而，我们的实现产生出减后的栈指针值，作为信号valE，然而再将这个信号即作为寄存器写的数据，也作为内存写的地址。因此，在时钟上升开始下一个周期时，处理器就可以同时执行寄存器写和内存写了。


## SEQ阶段的实现
![HCL描述中使用的常数量.PNG](HCL描述中使用的常数量.PNG)
* nop指令只是简单地经过各个截断，除了要将PC加一，不进行任何处理。halt指令使得处理器状态被设置成HLT，导致处理器停止运行。
#### 取指阶段
* 取指阶段包括指令内存硬件单元。以PC作为第一个字节的地址，这个单元一次从内存独处10个字节。第一个字节被解释成指令字节（标号为“Split”的单元）分为两个4位的数。然后，标号为“icode”和“ifun”的控制逻辑块计算指令和功能码，或者使之等于从内存读入的值，或者当指令地址不合法时（由信号imem_error指明），使这些值对应于nop指令，根据icode的值，我们可以计算三个一位的信号（用虚线表示）。instr_valid：这个字节用来发现一个不合法的Y86指令。当指令地址越解释会产生的信号instr_valid和imem_error在访存阶段被用来产生状态码。
![SEQ的取指阶段.png](SEQ的取指阶段.PNG)
#### 译码和写回阶段
* 把两个阶段联系在一起是因为他们都要访问寄存器文件
* 寄存器文件有四个端口。它支持同时进行两个读（端口A和B）和两个写（端口E和M）。每个断就都有一个地址链接和一个数据链接。地址链接是一个寄存器ID，而数据链接十一组64跟线路，既可以作为寄存器文件的输出字（对读端口来说），也可以作为它的输入字（对写端口来说）。两个度端口的地址输入为srcA和srcB，而两个写端口的地址输入为dstE和dstM。如果某个地址端口上的值为特殊标识符0xF(RNONE)，则表明不需要访问寄存器
