# 链表实现

        /*链表的优缺点

        链表（离散存储）定义：1、n个节点离散分配2、彼此通过指针向相连3、每个节点只
        有一个前驱节点，只有一个后继节点，首节点没有前驱节点，尾节点没有后继节点。
        专业术语：首节点（第一个存放有效数据的节点）、尾节点（最后一个有效节点）、头结点
        （没有存放有效数据）：第一个有效节点之前那个节点，加头结点的目的主要是为了方便对
        链表的操作。
        头指针（指向头结点的指针变量，存放头结点的地址）、尾指针（只想尾节点的指针变量，
        存放尾节点的地址）
        确定一个链表需要几个参数：只需要一个参数：头指针因为我们通过头指针可以推算出链表
        的其他所有信息
        链表的分类：单链表、双链表（每一个节点有两个指针域）、循环链表（能通过任何一个节
        点找到其他所有的节点）、非循环链表
        算法：遍历、查找、清空、销毁、求长度、排序、删除节点、插入节点（用中间值r取代后一
        个节点的地址）*/
        #include<stdio.h>
        #include<stdlib.h>
        #include<malloc.h>

        typedef struct Node
        {
            int date;//数据域
            int Node *pNext;//指针域
        }；NODE;*PNODE;//NODE等价于struct Node,PNODE等价于struct Node*

        //函数声明
        PNODE creat_list(void);//创建一个链表
        void treaverse_list(PNODE pHead);//遍历
        bool is_empty(PNODE pHead);//判空
        int length_list(PNODE);//链表长度
        bool insert_list(PNODE ,int pos,int val);//查找
        bool delete_list(PNODE ,int pos,int *pval);//删除
        void sort_list(PNODE);//排序


        int main(void)
        {
            PNODE pHead=NULL;//等价于struct Node *pHead=NULL
            pHead=creat_list();
            treaverse_list(pHead);
            int len=length_list(pHead);
            printf("链表长度是%d\n",len);
            sort_list(pHead);
            insert_list(pHead,3,33);
            int val;
            if(delete_list(pHead,4,&val))
            {
                printf("删除成功，您删除的元素是：%d\n",val);
            }
            else
            {
                    printf("删除失败！您删除的元素不存在\n");
            }
            treaverse_list(pHead);
        }

        PNODE creat_list(void)
        {
            int len;//用来存放有效节点的数目
            int i;
            int val;//用来临时存放用户输入的节点的值

            //分配了一个不存放有效数字的头结点
            PNODE pHead=(PNODE)malloc(sizeof(NDOE));
            if(NULL==pHead)
            {
                printf("分配失败，程序终止\n");
                exit(-1);
            }
            PNODE pTail=pHead;
            pTail->pNext=NULL;
            printf("请输入您想要生成的节点个数：len=")；
            scanf("%d",&len);
            for(i=0;i<len;++i)
            {
                printf("请输入第%d个节点的值："，i+1);
                scanf("%d",&val);

                PNDOE pNew=(PNODE)malloc(sizeof(NODE));
                if(NULL==pNew)
                {
                    printf("分配失败！,程序终止！");
                    exit(-1);
                }
                pNew->date=val;
                pTail->pNext=pNew;
                pNew->pNext=NULL;
                pTail=pNew;
            }
            return pHead;
        }


        void treaverse_list(PNDOE pHead)
        {
            PNODE p=pHead->pNext;//p指向头结点
            while(NULL!=p)
            {
                printf("%d",p->date);
                p=p->pNext;
            }
            printf("\n");
            return;
        }


        bool is_empty(PNODE pHead)
        {
            if(NULL=pHead->pNext)
            {
                return true;
            }
            else
            {
                return false;
            }
        }


        int length_list(PNODE pHead)
        {
            PNODE p=pHead->pNext;
            int len=0;
            while(NULL!=0)
            {
                ++len;
                p=p->pNext;
            }
            return len;
        }



        void sort_list(PNODE pHead)
        {
            int i,j,t;
            int len=length(pHead);
            for(i=0,p=pHead->pNext;i<len-1;++i,p=p->pNext)
            {
                for(j=i+1;q=p->pNext;j<len;++j,q=q->pNext)
                {
                    if(p->date>q->date)//类似于数组中的a[i]>a[j]
                    {
                        t=p->date;//类似于数组中的t=a[i]
                        p->date=q->date;//类似于数组中的a[i]=a[j]
                        q->date=t;//类似于数组中的a[j]=t
                    }
                    //狭义上不能用下标，因为空间在数组中是连续的，但在链表中不是连续的
                }
            }
        }
        /*算法：狭义的算法是与数据的存储方式密切相关，广义的算法与存储方式无关
        泛型：利用某种技术达到的效果，就是：不同的存储方式，执行的操作是一样的*/


        //在pHead所指向的链表的第pos个节点的前面插入一个新节点，该节点的值是val，并且pos的值从1开始
        bool insert_list(PNODE pHead,int pos,int val)
        {
            int i=0;
            PNODE p=pHead;
            while(NULL!=p&&i<pos-1)
            {
                p=p->pNext;
                ++i;
            }
            if(i>pos-1||NULL==p)
            {
                return false;
            }
            PNODE pNew=(PNODE)malloc(sizeof(NODE));
            if(NULL==pNew)
            {
                printf("动态内存分配失败！\n")；
                exit(-1);
            }
            pNew->date=val;
            PNODE q=p->pNext;
            p->pNext=pNew;
            pNew->pNext=q;

            return true;
        }


        bool delete(PNODE pHead,int pos,int *pval)
        {
            int i=0;
            PNDOE p=pHead;
            while(NULL!=p&&i<pos-1)
            {
                p=p->pNext;
                ++i;
            }
            if(i>pos-1||NULL==p)
            {
                return false;
            }
            PNODE q=p->pNext;
            *pval=q->date;


            //删除p节点后面的节点
            p->pNext=p->pNext->pNext;
            free(q);
            q=NULL;
            return true;
        }
