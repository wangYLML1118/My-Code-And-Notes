## 如何建立图
#### 用邻接矩阵表示图


        if(G[i][j]==1)
        {
            表示<vi,vj>是G中的边
        }
        else if(G[i][j]==0)
        {
            表示否则
        }
        /*用代码表示为
        typedef struct GNode *PtrToGNode;
        struct GNode
        {
            int Nv;//顶点数
            int Ne;//边数
            weightType G[MaxVertexNum][MaxVertexNum];
            //DateType Date[MaxVertexNum];//存顶点数据
        }；
        typedef PtrToGNode MGraph;//以邻接矩阵存储的图类型
        */

* MGraph初始化
* 初始化一个有VertexNum个顶点但没有边的图

        typedef int Vertex;//用顶点下标表示顶点
        MGraph CreatGraph(int VertexNum)
        {
            Vertex V,M;
            MGraph Graph;

            Graph=(MGraph)malloc(sizeof(struct GNode));
            Graph->Nv=VertxNum;
            Grapg->Ne=0;

            /*注意：这里默认编号从0开始，到(Graph->Nv-1)*/
            for(V=0;V<Graph->Nv;V++)
            {
                for(W=0;W<Graph->Nv;W++)
                {
                    Graph->G[V][W]=0;//或INFINITY
                }
            }
        }


* 向MGraph中插入边

        typedef struct ENode *PtrToENode;
        struct ENode
        {
            Vertex V1,V2;//有向边<v1,v2>
            WeightType Weight;//权重
        };
        typedef PtrToNode Edge;

        void InsertEdge(MGraph Graph,Edge E)
        {
            //插入边
            Graph->G[E->V2][E->V1]=E->weight;
            //若是无向图，还要插入边<V1,V2>
            Graph->G[E->V2][E->V1]=E->Weight;
        }


* 完整地建立一个MGraph
* 输入格式Nv,Ne,V1,V2,Weight

        MGraph BuildGraph()
        {
            MGraph Graph;
            Edge E;
            Vertex V;
            int Nv,i;

            scanf("%d",&Nv);
            Graph=CreatGraph(Nv);
            scanf("%d",&Graph->Ne);
            if(Graph->Ne!=0)
            {
                E=(Edge)malloc(sizeof(struct ENode));
                for(i=0;i<Graph->Ne;i++)
                {
                    scanf("%d %d %d",&E->E1,&E->E2,&E->E3);
                }
            }
            //如果定点有数据的话，读入数据
            for(V=0;V<Graph->Nv,V++)
            {
                scanf(" %c",&(Graph->Date[V]));
            }
            return Graph;
        }

* 简单地建立一个图

        int G[MAXN][MAXN]，Nv,Ne;
        void BuildGraph()
        {
            int i,j,v1,v2,w;
            scanf("%d",&Nv);
            //CreatGraph
            for(i=0;i<Nv;i++)
            {
                for(j=0;j<Nv;j++)
                {
                    G[i][j]=0;//或INFINITY
                }
                scanf("%d",&Ne);
                for(i=0;i<Ne;i++)
                {
                    scanf("%d %d %d",&v1,%v2,&w);
                }
                //InsertEdge
                G[v1][v2]=w;
                G[v2][v1]=w;
            }
        }


#### 用邻接表表示图
* 邻接表：G[N]为指针数组，对应矩阵每行一个链表，只存非元素

        typedef struct Vnode
        {
            PtrToAdjVNode FirstEdge;
        };AdjList[MaxVertexNum];
        //AdjList是邻接表类型
        typedef struct GNode *PtrToGNode;
        struct GNode
        {
            int Nv;//顶点数
            int Ne;//边数
            AdjList G;//邻接表
        };
        typedef PteToGNode LGraph;
        //以邻接表的方式存储的图类
        typedef struct AdjVNode *PtrToAdjVNode;
        struct AdjVNode
        {
            Vertex Adjv;//邻接点下标
            WeightType Weight;//边权重
            PtrToAdjVNode Next;
        }

#### LGraph初始化
* 初始化一个有VertexNum个顶点但没有边的图

        typedef int Vertex;//用顶点下标表示顶点，为整型
        LGraph CreatGraph(itn VertexNum)
        {
            Vertex V,W;
            LGraph Graph;

            Graph=(LGraph)malloc(sizeof(struct GNode));
            Graph->Nv=VertexNum;
            Graph->Ne=0;


            Graph->G[V].FirstEdge=NULL;
            return Graph;
        }

#### 向LGraph中插入边

        void InsertEdge(LGraph Graph.Edge E)
        {
            PtrToAdjVNode NewNode;

            //*********插入边<V1,V2>
            //为V2建立新的邻接点
            NewNode=(PtrToAdjVNode)malloc(sizeof(struct AdjVNode));
            NewNode->AdjV=E->V2;
            NewNode->Weight=E->Weight;

            //*********若是无向图，还要插入边<V1,V2>
            //为V1建立新的邻接点
            NewNode=(PtrToVNode)malloc(sizeof(struct AdjVNode));
            NewNode->AdjV=E->V1;
            NewNode->Weight=E->Weight;
            //将V1插入V2的表头
            NewNode->Next=Graph->G[E->V2].FirstEdge;
            Graph->G[E->V2].FirstEdge=NewNode;
        }