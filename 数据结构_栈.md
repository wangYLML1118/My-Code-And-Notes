# 栈 ADT、队列 ADT
## 栈模型
* 栈(stack)是限制插入和删除只能在一个位置上进行的表。该位置是表的末端，叫做栈的顶(Top)。对栈的基本操作有Push（入栈）和Pop（出栈），前者相当于插入，后者是删除最后一个插入的元素。
* 栈有时被叫做LIFO（先进后出）表，普通的清空栈操作和判断是否为空栈的操作都是栈操作指令的一部分，但是对栈所能做的也基本上就是Push和Pop操作。
## 栈的实现
* 由于栈是一个表，因此任何实现表的方法都能实现栈。两种较为流行的方法：一种使用指针，另一种使用数组。
#### 栈的链表实现
* 栈的第一种实现方法是单链表。我们通过在表顶端插入实现Push，通过删除表顶端元素实现Pop。Pop操作只是考察表顶端元素并返回它的值。又是Pop操作和Top操作合二为一。

        struct Node
        {
            ElementType Element;
            PtrToNode Next;
        };
        struct Node* Creatstack(void)
        {
            struct Node S;//创建一个空栈
            S=malloc(sizeof(struct Node));
            if(S=NULL)
            {
                FatalError("out of space!!!");
            }
            S->Next=NULL;
            return S;
        }
* Push是作为想来年表前端进行插入而实现的，其中，表的前端作为栈顶。Top的实施是通过考察表在第一个位置上的元素而完成的。最后，Pop是通过删除摆动二前端的元素而实现的。

        //Push进栈
        void Push(ElementType X,Stack S)
        {
            PtrToNode TmpCell;

            TmpCell=malloc(sizeof(struct Node));
            if(TmpCell=NULL)
            {
                FatalError(out of space!!!");
            }
            else
            {
                TmpCell->Element=X;
                TmpCell->Next=S-Next;
                S->Next=TmpCell;
            }
        }



        //从栈弹出元素
        void Pop(Stack S)
        {
            PtrToNode FirstCell;

            if(IsEmpty(S))
            {
                Error("Empty stack!!");
            }
            else
            {
                FirstCell=S->Next;
                S->Next=S->Next->Next;
                free(FirstCell);
            }
        }

## 队列模型
* 队列的基本操作是入队(Enqueue),它是在表的末端（叫做队尾（rear））插入一个元素。还有出队（Dequeue）操作，他是删除（或返回）在表的开头（叫做队头（front））的元素。

## 队列的数组实现
* 如同栈的情形一样，对于队列而言，任何表实现都是合法的，像栈一样，人对于每一种操作，链表实现和数组实现都给出快速的O（1）运行时间，队列的链表实现是直接的

        struct QueueRecord
        {
            int Capacity;
            int Front;
            int Rear;
            int Size;
            ElementType *Array;
        };

        //构造空队列
        void MakeEmpty(Queue Q)
        {
            Q->Size=0;
            Q->Front=1;
            Q->Rear=0;
        }
        //入队
        static int Succ(int Value,Queue Q)
        {
            if(++Value==Q->Capacity)
            {
                value=0
            }
            return Value;
        }
        void Emqueue(EleementType X,Queue Q)
        {
            if(IsFull(Q))
            {
                Error("Full Queue!!!!");
            }
            else
            {
                Q->Size++;
                Q->Rear=Succ(Q->Rear,Q);
                Q->Array[Q->Rear]=x;
            }
        }