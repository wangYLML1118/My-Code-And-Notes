## 什么是数据结构

* 数据对象在计算机中的组织方式
  * 逻辑结构
  * 物理存储结构
  
* 数据对象必定与一系列加在气上的操作相关联

* 完成这些操作的就是算法

## 描述数据结构

### 抽象数据类型

* 数据类型
  >* 数据对象集
  >* 数据集合相关联的操作集
* 抽象：描述数据类型的方法不依赖于具体实现
  >* 与存放数据的机器无关
  >* 与数据存储的物理结构无关
  >* 与实现操作的算法和编程语言均无关
### 例如：“矩阵”的抽象数据类型定义
* 类型名称：矩阵（Matrix）
* 数据对象集：一个M×N的矩阵A（M×N）=（a(ij)）(i=1,...M;j=1,...N)由M×N个三元组<a,i,j>组成，其中a是矩阵元素的值，i是元素所在的行号，j是元素所在的列好。
* 操作集：对矩阵的各种操作的集合

## 什么是算法

### 算法
* 一个有限指令集
* 接受一些输入（有些情况下不需要输入）
* 产生输入
* 一定在有限步骤之后终止
* 每一条指令必须
  * 有充分明确的目标。不可以有歧义
  * 计算机可处理的范围之内
  * 描述应不依赖与于任何一种计算机语言以及具体的实现手段
  
* 选择排序算法的伪码描述

        void SelectionSort(int List[],int n)
        {//将N个整数List[0]...List[N-1]进行非递减排序
            for(i=0;i<n;i++)
            {   
                MinPosition=ScanForMin(List,i,n-1);
                //从List[i]到List[N-1]中找到最小元，并将其位置赋给MinPostition;
                Swap(List[i],List[MinPosition]);
                //将未排序部分的最小元换到有序部分的最后位置；
            }
        }
    * 抽象一、List到底是数组还是链表（虽然看上去很像数组）？
    * 抽象二、Swap用函数还是宏去实现？

### 什么是好的算法
* 空间复杂度S(n)——根据算法写成的程序在执行时占用存储单元的长度。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致内存超限，造成程序非正常中断。
* 时间复杂度T(n)——根据算法写成的程序在执行时耗费时间的长度。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果。
* 最坏情况复杂度T(worst)(n)
* 平均情况复杂度T(avg)(n)
  * T(avg)(n)<=T(worst)(n)

## 最大子列和
* 算法1（暴力）
  
        int MaxSubseqSum1(int A[],int N)
        {
            int i,j,k;
            for(i=0;i<n;i++)
            {//i是子列左端位置
                for(k=i;k<=j;k++)
                {//j是子列右端位置
                    Thissum=0;//Thissum是从A[i]到A[j]的子列和
                    for(k=i;k<=j;k++)
                    {
                        ThisSum+=A[k];
                    }
                    if(ThisSum>MaxSum)//如果刚得到的子列和更大
                    {
                        MaxSum=ThisSum;//则更新结果
                    }
                }//j循环结束
            }//i循环结束
            return MaxSum;
        }
* 算法复杂度为O(N^3);
* 算法2

        int MaxSubseqSum2( int A[], int N )  
        {
            int ThisSum, MaxSum = 0;
            int i, j;
            for( i = 0; i < N; i++ )
            { /* i是子列左端位置 */
                ThisSum = 0;  /* ThisSum是从A[i]到A[j]的子列和 */
                for( j = i; j < N; j++ ) 
                { /* j是子列右端位置 */
                    ThisSum += A[j];        /*对于相同的i，不同的j，只要在j-1次循环的基础累加1项即可*/ 
                    if( ThisSum > MaxSum ) /* 如果刚得到的这个子列和更大 */
                        MaxSum = ThisSum;    /* 则更新结果 */
                } /* j循环结束 */    
            } /* i循环结束 */    
            return MaxSum;  
        }
* 算法复杂度为O(N^2)
* 分而治之（二分法）
* T(N)=2*T(N/2)+c(N)=2*[2*T(n/2^2)+c*(N/2)]+c*N=2^k*O(1)+c*k*N,其中N/2^k=1,T(1)=O(1)
  
![分而治之](/home/picture/分而治之.png/“分而治之”)

* 算法4:在线处理

        int MaxSubseqSum4(int A[],int N)
        {
            int ThisSum,MaxSum;
            int i;
            ThisSum=MaxSum=0;
            for(i=0;i<n;i++)
            {
                ThisSum+=A[i];//向右累加
                if(ThisSum<MaxSum>)
                {
                    MaxSum=ThisSum;//发现更大则刷新当前结果
                }
                else if(ThisSum<0)//如果当前子列和为负
                {
                    ThisSum=0;//则不可能是后面的部分增大，抛弃之
                }
                return MaxSum;
            }
        }